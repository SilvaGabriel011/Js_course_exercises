day 15 02072025
    destructuring arrays 
        const [value1, , value2] = object.propertieThatIsAFunction(parameter1, parameter2)
                the empty space is when we want to skip and element
            returns the values that the functions propose as 2 separate value 
                or smothing like that
    destruct objects
        its useful to set default values
        arr = [ 7,8,9]
        newArr = [1,2,...arr]
            the spread operator write the values individually 
        spread operator takes the eelements from the array and dosent create new variables
        const copyArray = [...oldArray]
            creates a shallow copy of the array 
        multiple values separeted by a coma are only expected when we pass arguments into a function or when building a new array 
        can copy the object into a new one with spread (...)
            const newObject = {...object}
                newObject.propertie = new value
                    it doesnt change the propertie from the original/first object 

    rest parameter and parameters 
        pack elements into a array
        const [a,b,...others] = [1, 2, 3, 4, 5]
            its a rest operathor because it is on the left side of the equality 
            the rest should be the last element 
        const add = function(...numbers){
                the ... are being compressed into one array 
                    doesnt matter how many argments are being passed 
            sum = 0
            for(let i =0; i < numbers.length; i++) sum += numbers[i]
        }
        add(2,3)
        add(3,4,5,6)
        so rest can be used when we would write names separate by comas
    
    SHORT CIRCUITING (&& AND ||)
        it can be used any data type and can return any data type
        short-circuiting 
        ||operator
            if the first value is truthy/true value
                the second dosent get evalueated
            if all of the operators are falsy, returns the last one 
        in the && when the evaluation gets to a alement that its falsy it returns it 
            so the first value that has falsy/false type of data it's returned 
            returns the last element if all are truthy 
     
    the nullish coalescing opeartor 
        ??
        works with the idea of nullish values
            null and undefined 
            only those two will shortcut the evaluation 
        the first non nullish value is returned 
        link for stud better 
    https://chatgpt.com/share/6867d6f8-d864-800a-a9c6-18057044e17c


day16 03072025

    logical assignement operators
        the or (||) assignment operator 
            assignes a value to a variable if that variable is currently falsy 
                a.propertie = a.propertie || 10
                    can be write as 
                    a.propertie||= 10
                    if there are difference betwen the properties it will be then assigned the value 10 as a value of the propertie 
                        so if the object dosent have the propertie it will then get the propertie and also the value 10 

        the nullish asignment operator (??)
            it will evalueate if one of the values are null/undefined and if so it shortcut
                will assgine a value to a variable if that variable is nullish/undifined 
        
        the and asignment operator (&&)
            it will return the first falsy value 
                a.propertie = a.propertie && 'falsy'
                    if both of the properties are the same the 'falsy' is returned 
                    a.propertie &&= 'falsy'
    
    loop over arrays - for of loop
        automaticly loop over the entire array 
            and each iteration it will give acces to the current item iteration 
        its able to use continue/break 
        for (const item of items){block of code}

        exemple of destructuring a for of loop 

            for (const item of menu.entries()){
                console.log(`${item[0] + 1}: ${item[1]}`);
            }
                should return
                1: foccacia
                2: bruschetta ...

            with destructuring 
            for each pair of [index, value] give me i and el 
                
                for (const [i,el] of menu.entries()){
                    console.log(`${i + 1}: ${item[el]}`);
                }
                    should return
                    1: foccacia
                    2: bruschetta ...


day17 04072025

    enhanced object literals 
        put the object inside the other withou being repetitive 
            instead of a , properties:properties, b...
                a, propertie, b ... 
        dosent need to declare the function with the function keyword 
        also naming properties can be done dinamicaly with the used of []
            inside of the [] can be put anything that ir read as a value 
    
    optional chaning 
        if certain propertie does not exist its logged undefined 
            object.propertie?.propertie2
                only if the propertie behind the question mark exist the second propertie will be seached for
                if not undefined is returned 
        can be called for methods aswell
            object.method?.()
            the question mark test if the value on the left exists 
        its usually combined if the nullish coalescing operator 

    Looping objects 
        object.keys(objectCreated)
            return in an array all of the keys of the object inside the parentesis 
        object.values(objectCreated)
            return an object with the values 
                in a ordinated way 
        object.entries(objectCreated)
            return the index number and the element itself as an array 
                first the key and then the value 
            when we get the object and the array we can deconstruct to make more iterable

            exemple
                for (const [day, { open, close }] of entries)
                     {
                console.log(`On ${day} we open at ${open} and close at ${close}`);
                     }   